<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>HTTP/2 协议 | 在路上的博客</title>
  <meta name="author" content="Sven">
  
  <meta name="description" content="让大家读得懂的知识才是真知识">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="HTTP/2 协议"/>
  <meta property="og:site_name" content="在路上的博客"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="在路上的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">在路上的博客</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">关于我</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-03-31T06:39:00.000Z"><a href="/2019/03/31/http2/">2019-03-31</a></time>
      
      
  
    <h1 class="title">HTTP/2 协议</h1>
  

    </header>
    <div class="entry">
      
        <p>HTTP/1.1 与 HTTP/2 相隔了大概20年，但是从目前的研究和实验情况来看，我们不可能等上几十年才升级到下一个版本，h2 在逐渐的普及。<br>h2 和 h1 的最大差别在于在 <strong>http 层</strong>上增加了<strong>分帧层</strong>；把原来的 http 层的数据拆分成多种帧类型，并在每种类型前加上协议性的帧首部。基于二进制分帧的优点：</p>
<ol>
<li>传输使用的编码方式改变（采用帧、流模式），不用创建多个 TCP 连接，单个连接就可以有多个流（处理主页面和所有子元素的请求），能够减少延迟，服务器和浏览器的 socket 负载也大大减少。</li>
<li>并行处理，乱序发送帧，不再采用 pipeline 阻塞方式</li>
<li>传输的功能得以扩展（如服务端推送、首部压缩、优先级、流量控制）。</li>
</ol>
<p>学习 HTTP/2 最好的文档是 RFC 7540。</p>
<a id="more"></a>
<h2 id="1-nbsp-nbsp-连接"><a href="#1-nbsp-nbsp-连接" class="headerlink" title="1 &nbsp;&nbsp;连接"></a>1 &nbsp;&nbsp;连接</h2><hr>
<p>HTTP/2 对每一个域名只会开启一个连接（或者说 一个 TCP、一个 socket 都是可以的），HTTP/2 的设计思路是尽量在单个 TCP/IP socket 上通信。</p>
<h3 id="1-1-nbsp-nbsp-启用-http-2"><a href="#1-1-nbsp-nbsp-启用-http-2" class="headerlink" title="1.1 &nbsp;&nbsp;启用 http/2"></a>1.1 &nbsp;&nbsp;启用 http/2</h3><p>对于浏览器来说，它无法知晓该服务端是否支持了 h2，有三种方式来了解是否支持。</p>
<ul>
<li>为”http” URIs启用HTTP/2协议：客户端利用 Upgrade 首部来表明期望使用 h2；服务端返回 <code>101 Swiching Protocols</code>;</li>
<li>为”https” URIs启用HTTP/2协议：客户端在 ClientHello 中设置<strong>应用层协议协商</strong>（Application-Layer Protocol Negotiation，ALPN）扩展来表明期望使用 h2；服务端在 ServerHello 中同样返回，所以 h2 在创建 TLS 握手的过程中完成协商，不需要多余的网络通信。</li>
<li>先知情况下启用HTTP/2：使用 HTTP Alternative Services 或 Alt-Svc。</li>
</ul>
<h3 id="1-2-nbsp-nbsp-http-2-连接前奏"><a href="#1-2-nbsp-nbsp-http-2-连接前奏" class="headerlink" title="1.2 &nbsp;&nbsp; http/2 连接前奏"></a>1.2 &nbsp;&nbsp; http/2 连接前奏</h3><p>支持了之后还要再确认使用 h2，两端都需要发送前奏，作为对所使用协议的最终确认，并确定HTTP/2连接的初始设置。客户端和服务端各自发送不同的连接前奏。</p>
<ol>
<li>客户端连接前奏以一个24字节的序列开始，用十六进制表示为：<br><code>0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a</code><br>即，连接前奏以字符串”PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n”开始，一般称 Magic，注意它不是帧。这个序列后面必须跟一个可以为空的 SETTINGS 帧</li>
<li>服务端连接前奏包含一个可能为空的 SETTINGS 帧( 6.5节 )，它必须由服务端在HTTP/2连接中首先发送。</li>
<li>在发送完本端的连接前奏之后，必须对收到的作为对端连接前奏一部分的 SETTINGS 帧进行确认（ACK）。</li>
</ol>
<h3 id="1-3-nbsp-nbsp-SETTINGS-帧"><a href="#1-3-nbsp-nbsp-SETTINGS-帧" class="headerlink" title="1.3 &nbsp;&nbsp; SETTINGS 帧"></a>1.3 &nbsp;&nbsp; SETTINGS 帧</h3><p><strong>SETTINGS 帧只能应用到整个连接，不能应用于单个流</strong>，即 SETTINGS 帧的 stream identifier 必须为 0x0；</p>
<p>SETTINGS 帧包含了若干有序的键值对，每个键值对的格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------------------------+</span><br><span class="line">|       Identifier (16)         |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">|                        Value (32)                             |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure></p>
<p>SETTINGS 帧的标识符跟其它的不一样，只有 ACK 一个标识，取值 0x0 和 0x1，前者表示设置请求，后者表示确认响应；设置请求发送的 SETTINGS 帧包含了若干有序的键值对，确认响应没有负载数据。</p>
<p>Identifier 参数列表：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>默认值(octets)</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SETTINGS_HEADER_TABLE_SIZE (0x1)</td>
<td>4096</td>
<td>重新指定 HPACK 所用的首部表的最大尺寸</td>
</tr>
<tr>
<td>SETTINGS_ENABLE_PUSH (0x2)</td>
<td>1</td>
<td>如果设置为 0，当前端不会发送 PUSH_PROMISE</td>
</tr>
<tr>
<td>SETTINGS_MAX_CONCURRENT_STREAMS (0x3)</td>
<td>无限制</td>
<td>表明发送端能够并行接收的流的最大数量</td>
</tr>
<tr>
<td>SETTINGS_INITIAL_WINDOW_SIZE (0x4)</td>
<td>65535(64KB)</td>
<td>表明发送端流量控制的初始窗口尺寸</td>
</tr>
<tr>
<td>SETTINGS_MAX_FRAME_SIZE (0x5)</td>
<td>16384(16MB)</td>
<td>发送端希望接收的最大帧尺寸；这个值必须介于初始值和 2^24-1（16MB） 之间</td>
</tr>
<tr>
<td>SETTINGS_MAX_HEADER_LIST_SIZE (0x6)</td>
<td>无限制</td>
<td>该设置告诉通信的另一端，本端期望接收的最大首部的尺寸</td>
</tr>
</tbody>
</table>
<h3 id="1-4-nbsp-nbsp-PING-帧"><a href="#1-4-nbsp-nbsp-PING-帧" class="headerlink" title="1.4 &nbsp;&nbsp;PING 帧"></a>1.4 &nbsp;&nbsp;PING 帧</h3><p>PING 帧用以计算两端之间的往返时间 RTT，只有一个标识位 ACK，这个标识位和 SETTINGS 帧一样意识。</p>
<h3 id="1-5-nbsp-nbsp-关闭连接"><a href="#1-5-nbsp-nbsp-关闭连接" class="headerlink" title="1.5 &nbsp;&nbsp;关闭连接"></a>1.5 &nbsp;&nbsp;关闭连接</h3><p>GOAWAY 帧用于礼貌地关闭连接。这个是连接层的帧，也就是发送时流 ID 要设置为 0x0，</p>
<h2 id="2-nbsp-nbsp-帧"><a href="#2-nbsp-nbsp-帧" class="headerlink" title="2 &nbsp;&nbsp;帧"></a>2 &nbsp;&nbsp;帧</h2><hr>
<p>HTTP/2 是基于帧（frame）的协议，帧是 HTTP/2 最小传输单位；采用分帧是为了将重要的信息都封装起来，让协议的解析方轻松解析。基于帧的协议，所有的帧都固定用 9 个字节的帧首部加上帧负载数据组成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------------------------------------+</span><br><span class="line">|                 Length (24)                   |</span><br><span class="line">+---------------+---------------+---------------+</span><br><span class="line">|   Type (8)    |   Flags (8)   |</span><br><span class="line">+-+-------------+---------------+-------------------------------+</span><br><span class="line">|R|                 Stream Identifier (31)                      |</span><br><span class="line">+=+=============================================================+</span><br><span class="line">|                   Frame Payload (0...)                      ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<ol>
<li>帧首部字段解析：</li>
</ol>
<table>
<thead>
<tr>
<th>名称</th>
<th>长度</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Length</td>
<td>3字节</td>
<td>帧负载长度，2^14（16KB）是默认的最大帧长度，如果需要更大的帧，必须在 SETTINGS 帧设置</td>
</tr>
<tr>
<td>Type</td>
<td>1字节</td>
<td>当前帧类型</td>
</tr>
<tr>
<td>Flags</td>
<td>1字节</td>
<td>具体帧类型的标识，影响负载的协议结构</td>
</tr>
<tr>
<td>R</td>
<td>1位</td>
<td>保留位</td>
</tr>
<tr>
<td>Stream Identifier</td>
<td>31位</td>
<td>每个流的唯一 ID</td>
</tr>
<tr>
<td>Frame Payload</td>
<td>长度可变</td>
<td>真实的帧内容，长度为 Length</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>帧类型：</li>
</ol>
<table>
<thead>
<tr>
<th>名称</th>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DATA</td>
<td>0x0</td>
<td>传输流的核心内容</td>
</tr>
<tr>
<td>HEADERS</td>
<td>0x1</td>
<td>包含 HTTP 首部，和可选的优先级参数</td>
</tr>
<tr>
<td>PRIORITY</td>
<td>0x2</td>
<td>指示或者更改流的优先级和依赖</td>
</tr>
<tr>
<td>RST_STREAM</td>
<td>0x3</td>
<td>允许一端停止流</td>
</tr>
<tr>
<td>SETTINGS</td>
<td>0x4</td>
<td>协商连接级参数</td>
</tr>
<tr>
<td>PUSH_PROMISE</td>
<td>0x5</td>
<td>提示客户端，服务端要推送些东西</td>
</tr>
<tr>
<td>PING</td>
<td>0x6</td>
<td>测试连接可用性和往返时延（RTT）</td>
</tr>
<tr>
<td>GOAWAY</td>
<td>0x7</td>
<td>告诉另一端，当前端已结束</td>
</tr>
<tr>
<td>WINDOW_UPDATE</td>
<td>0x8</td>
<td>协商一端将要接收多少字节（用于流量控制）</td>
</tr>
<tr>
<td>CONTINUATION</td>
<td>0x9</td>
<td>用以扩展 HEADERS 数据块</td>
</tr>
</tbody>
</table>
<h2 id="3-nbsp-nbsp-流"><a href="#3-nbsp-nbsp-流" class="headerlink" title="3 &nbsp;&nbsp;流"></a>3 &nbsp;&nbsp;流</h2><hr>
<p>流（stream）的定义是：HTTP/2连接上独立、双向的帧序列交接。流代 ID 表示一次 HTTP 请求和响应所产生的一系列帧，流 ID 用来标识帧所属的流；单个 socket 上可以创建多个流，HTTP/2 的设计思路是尽量在单个 TCP/IP socket 上通信。<br>流 ID 在设计时就避免了客户端和服务端之间的流 ID 冲突，也可以轻地判断流的源头。</p>
<ul>
<li>客户端会从 1 开始设置流 ID，之后每新开启一个流，就会增加 2，并一直使用奇数。</li>
<li>服务端开启在 PUSH_PROMISE 中标明的流时，设置的流 ID 从 2 开始，之后一直使用偶数。</li>
<li>0 是保留数字，用于连接级控制消息，不能用于创建新的流。</li>
</ul>
<h3 id="3-1-nbsp-nbsp-消息"><a href="#3-1-nbsp-nbsp-消息" class="headerlink" title="3.1 &nbsp;&nbsp;消息"></a>3.1 &nbsp;&nbsp;消息</h3><p>帧消息的关注点在于 HEADERS 和 DATA 这两个帧类型，这也是由 h1 的头部和数据拆分而来。<br>帧首部必须以 +END_STREAM、+END_HEADERS 结束。</p>
<p><img src="http://img.jemper.cn/2019/03/request_response.png" alt="GET 或 POST 请求和响应消息"></p>
<p>h1 把 header 拆分成两部分：请求/状态行（GET / HTTP/1.1、HTTP/1.1 200 OK）、首部（Host、User-agent等）；而 h2 取消了这种拆分，<strong>一切都是 header</strong>，并引入了伪首部（Pseudo-Header）：<br>（1）请求伪首部：:method、:scheme、:authority、:path<br>（2）响应伪首部：:status</p>
<ol>
<li>HEADERS 帧<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|Pad Length? (8)|</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|E|                 Stream Dependency? (31)                     |</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|  Weight? (8)  |</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|                   Header Block Fragment (*)                 ...</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                           Padding (*)                       ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>帧字段的部分解析可以看 PRIORITY 帧。</p>
<p>标识位（Flags）：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>位</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>END_STREAM</td>
<td>0x1</td>
<td>表明这是流中最后的帧（流终止）</td>
</tr>
<tr>
<td>END_HEADERS</td>
<td>0x4</td>
<td>表明这是流中最后一个 HEADERS 帧；如果此标识未设置，表示随后会有 CONTINUATION 帧</td>
</tr>
<tr>
<td>PADDED</td>
<td>0x8</td>
<td>表明此帧添加了填充数据，要使用 Pad Length 和 Padding 字段</td>
</tr>
<tr>
<td>END_STREAM</td>
<td>0x20</td>
<td>设置了此标识，表明要使用 E、Stream Dependency 以及 Weight 字段</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>DATA 帧<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|Pad Length? (8)|</span><br><span class="line">+---------------+-----------------------------------------------+</span><br><span class="line">|                            Data (*)                         ...</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                           Padding (*)                       ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>标识位（Flags）：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>位</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>END_STREAM</td>
<td>0x1</td>
<td>表明这是流中最后的帧（流终止）</td>
</tr>
<tr>
<td>PADDED</td>
<td>0x8</td>
<td>表明此帧添加了填充数据，要使用 Pad Length 和 Padding 字段</td>
</tr>
</tbody>
</table>
<h3 id="3-3-nbsp-nbsp-流量控制"><a href="#3-3-nbsp-nbsp-流量控制" class="headerlink" title="3.3 &nbsp;&nbsp;流量控制"></a>3.3 &nbsp;&nbsp;流量控制</h3><p><strong>WINDOW_UPDATE 帧流量控制可以应用到单个流，也可以应用到连接承载的所有流（流 ID 为 0x0）</strong>，这点与 SETTINGS 不一样。需要注意的是，在单个流上指定的 WINDOW_UPDATE 帧也会作用于连接层的流量控制。<br>在流建立的时候，窗口大小默认都是 2^16-1(64KB)；流量控制不能关闭，把窗口最大值设定为 2^31-1（2GB） 就等效于禁用它；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-+-------------------------------------------------------------+</span><br><span class="line">|R|              Window Size Increment (31)                     |</span><br><span class="line">+-+-------------------------------------------------------------+</span><br></pre></td></tr></table></figure></p>
<p>该帧没有标识符（Flags）。</p>
<h3 id="3-4-nbsp-nbsp-优先级"><a href="#3-4-nbsp-nbsp-优先级" class="headerlink" title="3.4 &nbsp;&nbsp;优先级"></a>3.4 &nbsp;&nbsp;优先级</h3><p>客户端拿到页面分析依赖关系的时候是通过声明<strong>依赖关系</strong>树和树里的相对<strong>权重</strong>实现的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index.html</span><br><span class="line">- style.css</span><br><span class="line">  - critical.js</span><br><span class="line">    - less_critical.js(weight 20)</span><br><span class="line">    - photo.jpg(weight 8)</span><br><span class="line">    - header.jpg(weight 8)</span><br><span class="line">    - ad.js(weight 4)</span><br></pre></td></tr></table></figure></p>
<p>依赖树是客户端自己维护的，而权重则需要告诉服务端实现对象优先传输顺序，不过说到底，做什么以及如何处理优先级，最终还是得听服务器的，服务器仍有做它自己认为正确的事的权力。<br>那么客户端怎么告诉服务端的？通过 HEADERS 帧和 PRIORITY 帧，客户端可以明确的和服务沟通它需要什么，以及它需要这些资源的顺序。<br>PRIORITY 帧可以看成是 HEADERS 的子部分：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-+-------------------------------------------------------------+</span><br><span class="line">|E|                  Stream Dependency (31)                     |</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|   Weight (8)  |</span><br><span class="line">+-+-------------+</span><br></pre></td></tr></table></figure></p>
<p>帧字段：</p>
<ul>
<li>E 标识当前的流是否为专用，是否不依赖其他流</li>
<li>Stream Dependency 流依赖，如果当前流依赖其他流，标识其所依赖的流</li>
<li>Weight 当前流的相对权重</li>
</ul>
<p>该帧没有标识符（Flags）。</p>
<h3 id="3-5-nbsp-nbsp-CONTINUATON-帧"><a href="#3-5-nbsp-nbsp-CONTINUATON-帧" class="headerlink" title="3.5 &nbsp;&nbsp;CONTINUATON 帧"></a>3.5 &nbsp;&nbsp;CONTINUATON 帧</h3><p>有些帧的帧负载很简单，比如 DATA，只有 Pad Length 后面就是 DATA；有些帧负载配置较多，即当 HEADERS、PUSH_PROMISE 帧<strong>首部块片段</strong>（header Block Fragment）较大（少见），需要分帧传输，有两种选择：<br>（1）再次使用 HEADERS、PUSH_PROMISE 等帧，缺点是帧负载的配置重复传递，还得处理帧负载的配置有分歧的情况，可能引起麻烦。<br>（2）采用新的 CONTINUATON 帧，没有帧负载的配置，仅仅有 header Block Fragment，缺点是 CONTINUATON 和前面的帧必须是有序的，会减损多路复用的益处。</p>
<p>最终协议开发者选择了处理较为简洁的新帧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                   Header Block Fragment (*)                 ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>标识位（Flags）： </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>位</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>END_HEADERS</td>
<td>0x4</td>
<td>表明这是流中最后一个 HEADERS 帧；如果此标识未设置，表示随后会有 CONTINUATION 帧</td>
</tr>
</tbody>
</table>
<h3 id="3-6-nbsp-nbsp-关闭流"><a href="#3-6-nbsp-nbsp-关闭流" class="headerlink" title="3.6 &nbsp;&nbsp;关闭流"></a>3.6 &nbsp;&nbsp;关闭流</h3><p>如果要终止一个流，可以将 RST_STREAM 加在该流的两端。帧字段只有 32 位的 Error Code。</p>
<h2 id="4-nbsp-nbsp-推送响应"><a href="#4-nbsp-nbsp-推送响应" class="headerlink" title="4 &nbsp;&nbsp;推送响应"></a>4 &nbsp;&nbsp;推送响应</h2><hr>
<p>PUSH_PROMISE 帧可以看成是服务端响应的首部，字段如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|Pad Length? (8)|</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|R|                  Promised Stream ID (31)                    |</span><br><span class="line">+-+-----------------------------+-------------------------------+</span><br><span class="line">|                   Header Block Fragment (*)                 ...</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                           Padding (*)                       ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure></p>
<p>有几个属性需要理解：</p>
<ul>
<li>Promised Stream ID 推送响应一定会对应到客户端已发送的某个请求；</li>
<li>PUSH_PROMISE 和 HEADERS 帧字段是很相似的，比如 Promised Stream ID 和 Stream Dependency 是一样的意思，只是所处的角度不同所以描述不同；</li>
<li>:method 首部的值必须确保安全。安全的方法就是”幂等“的那些方法；</li>
<li>会创建新的偶数的流 ID；</li>
<li>被发送的对象必须确保是可缓存的；</li>
<li>应该早于客户端接收到可能承载着推送对象的 DATA 帧推送，比如客户端请求 HTML，那么服务器应早于完整推送 HTML 前推送 PUSH_PROMISE。不过 h2 足够健壮，可以优雅地解决这类问题，但确实是浪费流量了。</li>
</ul>
<p>客户端可以拒收，使用 RST_STREAM 帧。另外还有 PROTOCAL_ERROR 当 PUSH_PROMISE 涉及的协议不安全，或者客户端已经在 SETTINGS 帧中表明自己不接受推送时，仍然进行推送。不过在双方都了解对方想法前可能无法避免地推送大量资源。</p>
<p>如果服务器接收到一个页面的请求，它需要决定是推送页面上的资源还是等客户端来请求。决定的过程需要考虑到如下方面：</p>
<ul>
<li>资源已经在浏览器缓存中的概率；</li>
<li>从客户端来看这些资源的优先级；</li>
<li>可用的带宽，以及其他类似的会影响客户端接收推送的资源；</li>
</ul>
<p>如果服务器选择正解，那就真的有助于提升页面的整体性能，反之则会损耗页面性能，这也是如今通用服务端推送解决方案非常少的原因。估计在 APP 上应用场景较多。</p>
<h2 id="5-nbsp-nbsp-首部压缩"><a href="#5-nbsp-nbsp-首部压缩" class="headerlink" title="5 &nbsp;&nbsp;首部压缩"></a>5 &nbsp;&nbsp;首部压缩</h2><hr>
<p>HPACK 的文档为 rfc 7541</p>
<h3 id="5-1-nbsp-nbsp-索引表"><a href="#5-1-nbsp-nbsp-索引表" class="headerlink" title="5.1 &nbsp;&nbsp;索引表"></a>5.1 &nbsp;&nbsp;索引表</h3><p>请求端和响应端各维护了两张索引表。一张是静态表，见 <a href="https://tools.ietf.org/html/rfc7541#appendix-A" target="_blank" rel="noopener">Static Table Definition</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------+-----------------------------+---------------+</span><br><span class="line">| Index | Header Name                 | Header Value  |</span><br><span class="line">+-------+-----------------------------+---------------+</span><br><span class="line">| 1     | :authority                  |               |</span><br><span class="line">| 2     | :method                     | GET           |</span><br><span class="line">| 3     | :method                     | POST          |</span><br><span class="line">| 4     | :path                       | /             |</span><br><span class="line">| 5     | :path                       | /index.html   |</span><br><span class="line">| 6     | :scheme                     | http          |</span><br><span class="line">| 7     | :scheme                     | https         |</span><br><span class="line">| 8     | :status                     | 200           |</span><br><span class="line">| 9     | :status                     | 204           |</span><br><span class="line">|                                                     |</span><br><span class="line">|                       ......                        |</span><br><span class="line">|                                                     |</span><br><span class="line">| 58    | user-agent                  |               |</span><br><span class="line">| 59    | vary                        |               |</span><br><span class="line">| 60    | via                         |               |</span><br><span class="line">| 61    | www-authenticate            |               |</span><br><span class="line">+-------+-----------------------------+---------------+</span><br></pre></td></tr></table></figure></p>
<p>另一张动态表索引编号从 62 开始。</p>
<p>每个动态表只针对一个连接，每个连接的压缩解压缩的上下文有且仅有一个动态表。<br>什么是连接，抽象的说是HTTP依赖的可靠的传输层的连接，一般来说指的是一个TCP连接。 HTTP/2 中引入了多路复用的概念，对于同一个域名的多个请求，会复用同一个连接。</p>
<h3 id="5-2-nbsp-nbsp-控制规则"><a href="#5-2-nbsp-nbsp-控制规则" class="headerlink" title="5.2 &nbsp;&nbsp;控制规则"></a>5.2 &nbsp;&nbsp;控制规则</h3><ul>
<li>发送索引编号和文本值</li>
</ul>
<p>有趣轶事：</p>
<ol>
<li>魔法字节流的 PRI 其实就是美国国家安全局 PRISM（棱镜）监控计划的一个笑话。</li>
<li>由早期的 HTTP/2.0 改成 HTTP/2 表示不能保证语义向后兼容，也就是不会有 2.1、2.2 之类的版本。</li>
</ol>
<p> <strong>参考文献</strong><br>[1] Stephen Ludin, Javier Garza. HTTP/2 基础教程. 版次：2018年1月第1版<br>[2] 谈谈 HTTP/2 的协议协商机制. <a href="https://imququ.com/post/protocol-negotiation-in-http2.html" target="_blank" rel="noopener">https://imququ.com/post/protocol-negotiation-in-http2.html</a>. Apr 14, 2016<br>[3] HPACK 完全解析. <a href="https://www.jianshu.com/p/f44b930cfcac" target="_blank" rel="noopener">https://www.jianshu.com/p/f44b930cfcac</a> 2016.08.20</p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/HTTPS/">HTTPS</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/http/">http</a>, <a href="/tags/https/">https</a>, <a href="/tags/http2/">http2</a>, <a href="/tags/h2/">h2</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:blog.jemper.cn">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C/">C</a><small>1</small></li>
  
    <li><a href="/categories/DevOps/">DevOps</a><small>2</small></li>
  
    <li><a href="/categories/Docker/">Docker</a><small>1</small></li>
  
    <li><a href="/categories/Golang/">Golang</a><small>5</small></li>
  
    <li><a href="/categories/HTTPS/">HTTPS</a><small>5</small></li>
  
  </ul>
</div>


  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2019 Sven
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'wpxun';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
