<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>go I/O 操作 | 在路上</title>
  <meta name="author" content="Sven">
  
  <meta name="description" content="让大家读得懂的知识才是真知识">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="go I/O 操作"/>
  <meta property="og:site_name" content="在路上"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="在路上" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">在路上</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">关于我</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-03-13T06:55:00.000Z"><a href="/2019/03/13/go-io/">2019-03-13</a></time>
      
      
  
    <h1 class="title">go I/O 操作</h1>
  

    </header>
    <div class="entry">
      
        
			<div id="toc" class="toc-article">
				<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-nbsp-nbsp-简介"><span class="toc-text">1   简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-nbsp-nbsp-接口设计"><span class="toc-text">1.1   接口设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-nbsp-nbsp-实现设计"><span class="toc-text">1.2   实现设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-nbsp-nbsp-io-包"><span class="toc-text">1.3   io 包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-nbsp-nbsp-bufio-实现设计"><span class="toc-text">2   bufio 实现设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-nbsp-nbsp-bufio-Reader"><span class="toc-text">2.1   bufio.Reader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-nbsp-nbsp-bufio-Writer"><span class="toc-text">2.2   bufio.Writer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-nbsp-nbsp-bytes-buffer-实现设计"><span class="toc-text">3   bytes.buffer 实现设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-nbsp-nbsp-Socket-实现设计"><span class="toc-text">4   Socket 实现设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-nbsp-nbsp-ioutil-工具"><span class="toc-text">4   ioutil 工具</span></a></li></ol>
			</div>
		
        <p>理解 I/O 的一些概念问题可以先看另一篇文章<a href="/2019/03/11/c-socket/">《C Socket 编程》</a><br>Go 语言把 I/O 操作抽象成为 Reader 和 Writer 接口，并在 C 语言的基础上又设置了一层缓存操作。<br><a id="more"></a></p>
<h2 id="1-nbsp-nbsp-简介"><a href="#1-nbsp-nbsp-简介" class="headerlink" title="1 &nbsp;&nbsp;简介"></a>1 &nbsp;&nbsp;简介</h2><p>先进行接口设计，后进行实现设计，即对每一个接口方法进行设计。</p>
<h3 id="1-1-nbsp-nbsp-接口设计"><a href="#1-1-nbsp-nbsp-接口设计" class="headerlink" title="1.1 &nbsp;&nbsp;接口设计"></a>1.1 &nbsp;&nbsp;接口设计</h3><p>定义一个接口，是要设计一种方法集。在做接口设计的时候，每一个方法的具体功能一定要能表述出来；并且根据所有方法，其中可以汇总出核心必备的属性，当然接口不能拥有属性，这只是一种脑补的属性，有利于实现设计。</p>
<p>可以分析 io 的接口实现，包括所有接口的功能描述和脑补核心属性：</p>
<ul>
<li>io.Reader：只有一个 Read 方法<ol>
<li>Read 方法的功能：可以从中读取数据，可以分多次读取</li>
<li>脑补核心属性：有两个，一个是源比如字符串、文件等；另一个是对源的当前读取到的指向</li>
</ol>
</li>
<li>io.Writer：只有一个 Write 方法<ol>
<li>Write 方法的功能：可以把数据写进去，能写多少依据源的能力</li>
<li>脑补核心属性：直接一个源就可以了</li>
</ol>
</li>
</ul>
<h3 id="1-2-nbsp-nbsp-实现设计"><a href="#1-2-nbsp-nbsp-实现设计" class="headerlink" title="1.2 &nbsp;&nbsp;实现设计"></a>1.2 &nbsp;&nbsp;实现设计</h3><p>根据要实现的方法集的一种设计，并可以由此知道需要的属性。原则上对每一个方法，如果有输出的话，则无论采用哪种设计，对同样的输入（或者同样的无输入），应该要有同样的输出。<br>实现其实就是一种设计（当然也可以扩充其功能），比如 strings.Reader 基本上就是比较原始的设计，而 bufio.Reader 采用了缓冲的设计实现了同样的功能。接下来我们列举一些常用的实现，并分析其原理。</p>
<h3 id="1-3-nbsp-nbsp-io-包"><a href="#1-3-nbsp-nbsp-io-包" class="headerlink" title="1.3 &nbsp;&nbsp;io 包"></a>1.3 &nbsp;&nbsp;io 包</h3><p>io 包中定义有：</p>
<ul>
<li>大量的接口</li>
<li>一些通用函数</li>
<li>小量的接口实现，在原io中的实现并不常用，strings、bufio 等包对 io 的实现更常用一些。</li>
</ul>
<p>总体来看，io.go 主要是进行接口设计，实现设计是次要的。</p>
<h2 id="2-nbsp-nbsp-bufio-实现设计"><a href="#2-nbsp-nbsp-bufio-实现设计" class="headerlink" title="2 &nbsp;&nbsp;bufio 实现设计"></a>2 &nbsp;&nbsp;bufio 实现设计</h2><p>bufio.Reader 封装了 io.Reader，bufio.Writer 封装了 io.Writer，接下来就分别从这两个类型进行讲解。</p>
<h3 id="2-1-nbsp-nbsp-bufio-Reader"><a href="#2-1-nbsp-nbsp-bufio-Reader" class="headerlink" title="2.1 &nbsp;&nbsp;bufio.Reader"></a>2.1 &nbsp;&nbsp;bufio.Reader</h3><p>bufio 封装了对应 io 的同时多了 buf 属性，和对 buf 的控制r、w这两个属性，读和写其实就会优先从 buf 进行，</p>
<p>bufio.Reader 主要有buf、r、w、rd(io.Reader)等属性（其它属性对原理的理解相对次要所以不提），把读操作优化成“rd-&gt;buf-&gt;变量”，除了一些特殊情况还是保留“rd-&gt;变量”的读取方式。<br>读取主要分两类：1、确定读取长度，如bufio.Read，bufio.ReadByte等；2、确定读取到某个字符，如bufio.ReadSlice，bufio.ReadLine，bufio.ReadBytes，bufio.ReadString等</p>
<ol>
<li><p>bufio.Read：</p>
<ul>
<li>如果 buf 不为空，则从 buf 取数据尽可能多的把 p 填满（可能填不满，这种情况下即使io.Reader还有未读数据，也不会再去取，也就是只取 buf 数据）。</li>
<li>如果 buf 为空，即 r==w，则判断要取的长度是否大于buf，如果大于等于buf，再直接从io.Reader取，也只有这种情况下是直接取的即“rd-&gt;变量”；如果小于 buf，则把buf填满，然后回到1；</li>
</ul>
</li>
<li><p>ReadSlice 或 ReadLine<br>该两个方法比较底层，不建议使用，这里需要注意的，返回的其实是指向 bufio.buf 属性的切片，因为 bufio.buf 底层的数组指针一直不变，而值却在变，因为返回的切片区域可能会因为 bufio.buf 值的改变而改变，特别在多次调用时要注意。</p>
</li>
<li><p>ReadBytes 或 ReadString<br>这两个方法通过调用 ReadSlice 实现，并在最终 copy 到新创建的切片返回，所以多次读取很安全。 </p>
</li>
<li><p>WriteTo<br>它的功能是把全部数据写到 Writer，对于 bufio，必须分两步：</p>
<ul>
<li>第一步把当前的缓冲写到 Writer，内部函数 writeBuf 就是单纯把缓冲区写到 Writer</li>
<li>然后把还没有缓冲的问题写到 Writer，判断逻辑是：源 Reader 有 WriterTo 就调用其 WriterTo，没有就走 fill 填充（也就是调用源 Reader 的 Read 读取）</li>
</ul>
</li>
</ol>
<h3 id="2-2-nbsp-nbsp-bufio-Writer"><a href="#2-2-nbsp-nbsp-bufio-Writer" class="headerlink" title="2.2 &nbsp;&nbsp;bufio.Writer"></a>2.2 &nbsp;&nbsp;bufio.Writer</h3><p>如果写入的数据大于缓冲区，则直接写入。<br>写入只是写到缓冲区，注意需要调用 Flush 方法写入，否则即使是程序运行结束也不会写入。</p>
<ol>
<li>ReadFrom<ul>
<li>如果缓冲为空且源 ReaderFrom 存在，则直接从源里调用</li>
<li>否则循环的取到缓冲中，并 Flush</li>
</ul>
</li>
</ol>
<h2 id="3-nbsp-nbsp-bytes-buffer-实现设计"><a href="#3-nbsp-nbsp-bytes-buffer-实现设计" class="headerlink" title="3 &nbsp;&nbsp;bytes.buffer 实现设计"></a>3 &nbsp;&nbsp;bytes.buffer 实现设计</h2><p>主要属性有 buf []byte 和 off：read at &amp;buf[off], write at &amp;buf[len(buf)]</p>
<h2 id="4-nbsp-nbsp-Socket-实现设计"><a href="#4-nbsp-nbsp-Socket-实现设计" class="headerlink" title="4 &nbsp;&nbsp;Socket 实现设计"></a>4 &nbsp;&nbsp;Socket 实现设计</h2><p>首先我们看一下一段 TCP 代码 <a href="https://github.com/wpxun/blog/blob/master/sample/socket.go" target="_blank" rel="noopener">socker.go</a>。</p>
<p>net.Dial 和 net.Listen().Accept() 返回 socket，可读可写，本质上是经过以下步骤取得文件句柄的：<br>net.Listen().fd.accept() 取得 fd 句柄，然后创建 net.conn（实际上 socket 还要经过协议一层包装）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type conn struct &#123;</span><br><span class="line">	fd *netFD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抓包分析：以代码的逻辑，TCP 数据一定是完整传输的，且每次发送的时间都有 PSH 标识；但因为并发的原因，服务端仅一次且不确定时间地读取 TCP 数据，导致在服务端读取之后发送的数据没有继续读取。<br><img src="http://img.jemper.cn/2019/07/go-socket-sample.png" alt="发送与接收"></p>
<h2 id="4-nbsp-nbsp-ioutil-工具"><a href="#4-nbsp-nbsp-ioutil-工具" class="headerlink" title="4 &nbsp;&nbsp;ioutil 工具"></a>4 &nbsp;&nbsp;ioutil 工具</h2>
      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/Golang/">Golang</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/Golang/">Golang</a>, <a href="/tags/io/">io</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:blog.jemper.cn">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C/">C</a><small>1</small></li>
  
    <li><a href="/categories/DevOps/">DevOps</a><small>3</small></li>
  
    <li><a href="/categories/Docker/">Docker</a><small>4</small></li>
  
    <li><a href="/categories/Golang/">Golang</a><small>6</small></li>
  
    <li><a href="/categories/HTTP/">HTTP</a><small>5</small></li>
  
    <li><a href="/categories/云原生/">云原生</a><small>8</small></li>
  
    <li><a href="/categories/日记/">日记</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Docker/" style="font-size: 18px;">Docker</a> <a href="/tags/Golang/" style="font-size: 16px;">Golang</a> <a href="/tags/Go包/" style="font-size: 12px;">Go包</a> <a href="/tags/HTTP/" style="font-size: 14px;">HTTP</a> <a href="/tags/Jenkins/" style="font-size: 10px;">Jenkins</a> <a href="/tags/Kubernetes/" style="font-size: 20px;">Kubernetes</a> <a href="/tags/RPC/" style="font-size: 10px;">RPC</a> <a href="/tags/Service-Mesh/" style="font-size: 14px;">Service Mesh</a> <a href="/tags/Socket/" style="font-size: 12px;">Socket</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/TLS/" style="font-size: 14px;">TLS</a> <a href="/tags/io/" style="font-size: 12px;">io</a> <a href="/tags/协议/" style="font-size: 14px;">协议</a> <a href="/tags/容器/" style="font-size: 14px;">容器</a> <a href="/tags/密码学/" style="font-size: 10px;">密码学</a> <a href="/tags/工具/" style="font-size: 14px;">工具</a> <a href="/tags/并发/" style="font-size: 12px;">并发</a> <a href="/tags/架构/" style="font-size: 10px;">架构</a> <a href="/tags/编程/" style="font-size: 10px;">编程</a> <a href="/tags/网络/" style="font-size: 12px;">网络</a> <a href="/tags/调试/" style="font-size: 10px;">调试</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2019 Sven
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'wpxun';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
