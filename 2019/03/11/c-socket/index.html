<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>C Socket 编程 | 在路上的博客</title>
  <meta name="author" content="Sven">
  
  <meta name="description" content="让大家读得懂的知识才是真知识">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="C Socket 编程"/>
  <meta property="og:site_name" content="在路上的博客"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="在路上的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">在路上的博客</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">关于我</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-03-11T12:04:00.000Z"><a href="/2019/03/11/c-socket/">2019-03-11</a></time>
      
      
  
    <h1 class="title">C Socket 编程</h1>
  

    </header>
    <div class="entry">
      
        
			<div id="toc" class="toc-article">
				<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-nbsp-nbsp-套接字"><span class="toc-text">1   套接字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-nbsp-nbsp-Socket-编程"><span class="toc-text">2   Socket 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-nbsp-nbsp-TCP"><span class="toc-text">2.1   TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-nbsp-nbsp-服务端"><span class="toc-text">2.1.1   服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-nbsp-nbsp-客户端"><span class="toc-text">2.1.2   客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-nbsp-nbsp-UDP"><span class="toc-text">2.2   UDP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-nbsp-nbsp-并发服务器"><span class="toc-text">3   并发服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-nbsp-nbsp-多进程"><span class="toc-text">3.1   多进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-nbsp-nbsp-多线程"><span class="toc-text">3.2   多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-nbsp-nbsp-I-O-复用"><span class="toc-text">3.3   I/O 复用</span></a></li></ol></li></ol>
			</div>
		
        <p>一切皆文件，I/O 操作无处不在，文件、设备、管道、Socket等都是 I/O 操作。C 语言对文件 I/O 操作分两种，一种是无缓冲的（用户层无缓存区），返回的是文件描述符（int 整型），代表函数是 open、read、write 和 socket 等；另一种是有缓冲的（用户层设计了缓存区），返回是的数据流 Stream（FILE 结构体），代表函数是 fopen、fread、fwrite、putc、getc、fputs、fgets 和 fprintf等；不过 C 标准已经不再支持对文件（这里没有包括 socket）的无缓冲操作。<br><a id="more"></a><br>“文件句柄”一般是 windows 的术语，因为在 windows 中 socket 和文件是不一样的，而 Linux 不区分文件与 socket, 所以一般用“文件描述符”术语，其中0、1、2就是我们熟悉的标准输入、标准输出和标准错误，自定义的描述符从 3 开始由小到大顺序编号。</p>
<h2 id="1-nbsp-nbsp-套接字"><a href="#1-nbsp-nbsp-套接字" class="headerlink" title="1 &nbsp;&nbsp;套接字"></a>1 &nbsp;&nbsp;套接字</h2><p>服务端和客户端都需要通过 socket() 函数建立套接字，了解套接字的结构可以通过下面的命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adadeMacBook-Pro:lib ada$ netstat -an | grep tcp4</span><br><span class="line">Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)</span><br><span class="line">tcp4  628000      0  127.0.0.1.8090         127.0.0.1.54044        ESTABLISHED</span><br><span class="line">tcp4       0  10000  127.0.0.1.54044        127.0.0.1.8090         ESTABLISHED</span><br><span class="line">tcp4       0      0  *.8090                 *.*                    LISTEN</span><br></pre></td></tr></table></figure></p>
<p>上面三行输出内容中，LISTEN 是服务器监听 socket，第一个 ESTABLISHED 是服务器的连接 socket，第二是 ESTABLISHED 是客户端的连接 socket。根据上面列的信息，其实就可以知道套接字结构的主要属性：<br><img src="http://img.jemper.cn/2019/03/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BB%93%E6%9E%84.png?imageView2/2/w/300" alt="套接字结构"><br>接收（Recv-Q）和发送（Send-Q）的缓冲区大小由系统默认设置，也可以调用 setsockopt() getsockopt() 进行设置，主动关闭套接字后该套接字将只能 read，不能 send。<br>数据流虽然是数据报形式发送，到存放到缓冲区后就没有数据报概念了，因此只能读取到没有数据为止，不能假设写到连接一端的数据大小与从连接另一端读取的数据大小之间存在任何一致性，换句话说，在发送端通过调用一次 send() 传入的数据可以通过在另一端调用 recv() 多次来获取；而调用 recv() 一次可能返回调用 send() 多次所传入的数据。<br>Local Address 和 Foreign Address 也没什么虽然特别说的。<br>state 这个却需要深入理解，这部分可以参考<a href="/2019/03/10/tcpip-theory/">《TCP/IP 原理》</a>一文。</p>
<h2 id="2-nbsp-nbsp-Socket-编程"><a href="#2-nbsp-nbsp-Socket-编程" class="headerlink" title="2 &nbsp;&nbsp;Socket 编程"></a>2 &nbsp;&nbsp;Socket 编程</h2><h3 id="2-1-nbsp-nbsp-TCP"><a href="#2-1-nbsp-nbsp-TCP" class="headerlink" title="2.1 &nbsp;&nbsp;TCP"></a>2.1 &nbsp;&nbsp;TCP</h3><h4 id="2-1-1-nbsp-nbsp-服务端"><a href="#2-1-1-nbsp-nbsp-服务端" class="headerlink" title="2.1.1 &nbsp;&nbsp;服务端"></a>2.1.1 &nbsp;&nbsp;服务端</h4><p>接下来我们来看几个核心的函数，需要注意返回值。我以打电话来勾勒其轮廓。</p>
<ul>
<li>电话机：<code>int socket(int domain, int type, int protocal); 成功时返回文件描述符，失败时返回 -1</code>。1从参数上看，就可以知道，domain 是选择网络层协议（IPv4、IPv6 等），type 和 protocol 是选择传输层协议（TCP、UDP 等），所以就知道 TCP/IP 这两个是整个网络协议集合里面<strong>最重要的要素，即“协议”</strong>，选择了这两个，其它的协议也就随之确定了，比如选择了 TCP 就会有窗口协议等。</li>
<li>分配自己的电话号码：<code>int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen); 成功时返回 0，失败时返回 -1。</code>主要是设置端口，IP 地址一般自动获取。这一步是 socket <strong>另外两个要素，IP 地址和端口</strong>。</li>
<li>等待别人来电：<code>int listen(int sockfd, int backlog); 成功时返回0，失败时返回 -1。</code>backlog 指定监听套接字的完成连接队列的最大长度。<br>(1)未完成连接队列：未完成 3 次握手，如果完成连接队列已满，将忽略客户机新发来的 SYN，而不发 RST，原因参考《TCP/IP 原理》；<br>(2)完成连接队列：已完成 3 次握手，但未被应用程序的 accept 接受；</li>
<li>别人打来电话，接听：<code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 成功时返回文件描述符，失败时返回 -1。</code>这一步生成了新的 socket，这个新的 socket 状态马上变成 ESTABLISHED，而参数里的 sockfd 还是原来的 socket，继续保持监听。</li>
</ul>
<h4 id="2-1-2-nbsp-nbsp-客户端"><a href="#2-1-2-nbsp-nbsp-客户端" class="headerlink" title="2.1.2 &nbsp;&nbsp;客户端"></a>2.1.2 &nbsp;&nbsp;客户端</h4><p>还是以打电话来比喻。</p>
<ul>
<li>电话机：<code>int socket(int domain, int type, int protocal);</code> 这个和上面没任何区别。</li>
<li>打电话：<code>int connect(int sockfd, struct sockaddr *serv_addr, socklen_t addrlen); 成功是返回 0，失败时返回 -1。</code>客户端不用设置自己的密码。</li>
</ul>
<p><img src="http://img.jemper.cn/2019/03/TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png?imageView2/2/w/300" alt="TCP 套接字的工作流程"></p>
<h3 id="2-2-nbsp-nbsp-UDP"><a href="#2-2-nbsp-nbsp-UDP" class="headerlink" title="2.2 &nbsp;&nbsp;UDP"></a>2.2 &nbsp;&nbsp;UDP</h3><p><img src="http://img.jemper.cn/2019/03/UDP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png?imageView2/2/w/300" alt="UDP 套接字的工作流程"></p>
<h2 id="3-nbsp-nbsp-并发服务器"><a href="#3-nbsp-nbsp-并发服务器" class="headerlink" title="3 &nbsp;&nbsp;并发服务器"></a>3 &nbsp;&nbsp;并发服务器</h2><p>简单的循环服务器同一时刻只可以响应一个客户端的请求，只到一个客户端请求结束才开始接受下一个客户，并不实用，接下来讲几种并发模型。</p>
<h3 id="3-1-nbsp-nbsp-多进程"><a href="#3-1-nbsp-nbsp-多进程" class="headerlink" title="3.1 &nbsp;&nbsp;多进程"></a>3.1 &nbsp;&nbsp;多进程</h3><p>缺点是需要IPC通信和分时使用 CPU 产生的上下文切换（不同进程切换导致相关信息移出或者移入内存或 CPU 寄存器）开销。</p>
<h3 id="3-2-nbsp-nbsp-多线程"><a href="#3-2-nbsp-nbsp-多线程" class="headerlink" title="3.2 &nbsp;&nbsp;多线程"></a>3.2 &nbsp;&nbsp;多线程</h3><p>解决了多进程两个问题，但带来了同步问题，不过现在同步问题已经很多的解决方案，特别是 Go 更是在解决同步这一问题下足了功夫。<br><code>int pthread_create(pthread_t * restrict thread, const pthread_attr_t * restrict attr, void * (* start_routine)(void *), void * restrict arg); 成功时返回 0，失败时返回其它值。</code><br><code>int pthread_join(pthread_t thread, void ** status); 成功时返回 0，失败时返回其它值。</code>让调用函数的线程进入阻塞状态。<br><code>int pthread_detach(pthread_t thread); 成功时返回 0，失败时返回其他值。</code>调用该函数不会引起阻塞，可以通过该函数引导销毁线程创建的内存空间。</p>
<h3 id="3-3-nbsp-nbsp-I-O-复用"><a href="#3-3-nbsp-nbsp-I-O-复用" class="headerlink" title="3.3 &nbsp;&nbsp;I/O 复用"></a>3.3 &nbsp;&nbsp;I/O 复用</h3><p>不要过于依赖该模型，该方案并不适用于所有情况，应当根据目标服务器的特点采用不同实现方法。<br>复用：为了提高物理设备的效率，用最少的物理要素传递最多数据时使用的技术。有“时（time）分复用技术”和“频（frequency）分复用技术”。<br>select() 函数是最具代表性的实现复用服务器的方法，它将多个文件描述符集中到一起统一监视。<br><code>int select(int maxfd, fd_set * readset, fd_set * writeset, fd_set * exceptset, const struct timeval * timeout); 发生错误时返回 -1，超时返回时返回 0；因发生关注的事件返回时，返回大于 0 的值，该值是发生事件的文件描述符数。</code><br>(1) 文件描述符监视范围 maxfd = 最大的文件描述符值 + 1，加 1 是因为文件描述符的值从 0 开始。<br>(2) 对 fd_set 位变量的注册或者更改值的操作由宏完成，除了下面的宏，还有 FD_ISSET(int fd, fd_set *fdset) 用于验证 select 函数的调用结果。<br><img src="http://img.jemper.cn/2019/03/select%E5%AE%8F.png" alt="fd_set位 宏操作"><br>(3) select 函数调用后，fd_set 位值仍为 1 的位置上的文件描述符即是发生了变化的，监听但是没有变化的位会从 1 改变为 0，正因为 readset、writeset、exceptset 这三个集合在调用 select 函数后会发生变化，因此为了记住初始化，必须先复制保存起来以便后续继续监听；包括超时时间也需要先复制初始值，因为调用 select 后会更新为剩余时间。</p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/C/">C</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/C/">C</a>, <a href="/tags/Socket/">Socket</a>, <a href="/tags/编程/">编程</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:blog.jemper.cn">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C/">C</a><small>1</small></li>
  
    <li><a href="/categories/DevOps/">DevOps</a><small>2</small></li>
  
    <li><a href="/categories/Docker/">Docker</a><small>1</small></li>
  
    <li><a href="/categories/Golang/">Golang</a><small>6</small></li>
  
    <li><a href="/categories/HTTPS/">HTTPS</a><small>5</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/Apline/" style="font-size: 10px;">Apline</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/DevOps/" style="font-size: 10px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Golang/" style="font-size: 20px;">Golang</a> <a href="/tags/H2/" style="font-size: 13.33px;">H2</a> <a href="/tags/HTTP2/" style="font-size: 13.33px;">HTTP2</a> <a href="/tags/HTTPS/" style="font-size: 16.67px;">HTTPS</a> <a href="/tags/IP/" style="font-size: 10px;">IP</a> <a href="/tags/RPC/" style="font-size: 10px;">RPC</a> <a href="/tags/SSL/" style="font-size: 10px;">SSL</a> <a href="/tags/Socket/" style="font-size: 13.33px;">Socket</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/TLS/" style="font-size: 16.67px;">TLS</a> <a href="/tags/context/" style="font-size: 10px;">context</a> <a href="/tags/dockerfile/" style="font-size: 10px;">dockerfile</a> <a href="/tags/io/" style="font-size: 10px;">io</a> <a href="/tags/network/" style="font-size: 10px;">network</a> <a href="/tags/time/" style="font-size: 10px;">time</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/协议/" style="font-size: 13.33px;">协议</a> <a href="/tags/密码学/" style="font-size: 10px;">密码学</a> <a href="/tags/工具/" style="font-size: 16.67px;">工具</a> <a href="/tags/并发/" style="font-size: 13.33px;">并发</a> <a href="/tags/微服务/" style="font-size: 10px;">微服务</a> <a href="/tags/性能/" style="font-size: 13.33px;">性能</a> <a href="/tags/架构/" style="font-size: 13.33px;">架构</a> <a href="/tags/编程/" style="font-size: 10px;">编程</a> <a href="/tags/调试/" style="font-size: 10px;">调试</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2019 Sven
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'wpxun';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
