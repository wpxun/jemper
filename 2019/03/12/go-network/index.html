<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>go 网络编程 | 在路上</title>
  <meta name="author" content="Sven">
  
  <meta name="description" content="让大家读得懂的知识才是真知识">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="go 网络编程"/>
  <meta property="og:site_name" content="在路上"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="在路上" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">在路上</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">关于我</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-03-12T01:30:00.000Z"><a href="/2019/03/12/go-network/">2019-03-12</a></time>
      
      
  
    <h1 class="title">go 网络编程</h1>
  

    </header>
    <div class="entry">
      
        
			<div id="toc" class="toc-article">
				<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-nbsp-nbsp-Go-HTTP-原理"><span class="toc-text">1   Go HTTP 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-nbsp-nbsp-服务端"><span class="toc-text">1.1   服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-nbsp-nbsp-三层逻辑"><span class="toc-text">1.1.1   三层逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-nbsp-nbsp-细节剖析"><span class="toc-text">1.1.2   细节剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-nbsp-nbsp-客户端"><span class="toc-text">1.2   客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-nbsp-nbsp-基于-TCP-的-HTTP-客户端"><span class="toc-text">1.2.1   基于 TCP 的 HTTP 客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-nbsp-nbsp-基于-http-Client-的-HTTP-客户端"><span class="toc-text">1.2.2   基于 http.Client 的 HTTP 客户端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-nbsp-nbsp-RPC"><span class="toc-text">2   RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-概述"><span class="toc-text">2.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-nbsp-nbsp-基于-TCP-的标准包-RPC"><span class="toc-text">2.2   基于 TCP 的标准包 RPC</span></a></li></ol></li></ol>
			</div>
		
        <p>本篇主要内容是 Go HTTP 原理和 RPC 相关知识。<br>在进行原理讲解之前我觉得有必要熟悉一下 <a href="/2019/03/10/tcp-protocol/">TCP 传输原理</a>和 <a href="/2019/03/11/c-socket/">C Socket 编程</a>，因为 Go 是在 C 的基础上进行封装的，这样对哪些属于 C，哪些属于 Go 有一个清晰的了解，也更能避繁就简。<br><a id="more"></a></p>
<h2 id="1-nbsp-nbsp-Go-HTTP-原理"><a href="#1-nbsp-nbsp-Go-HTTP-原理" class="headerlink" title="1 &nbsp;&nbsp;Go HTTP 原理"></a>1 &nbsp;&nbsp;Go HTTP 原理</h2><h3 id="1-1-nbsp-nbsp-服务端"><a href="#1-1-nbsp-nbsp-服务端" class="headerlink" title="1.1 &nbsp;&nbsp;服务端"></a>1.1 &nbsp;&nbsp;服务端</h3><h4 id="1-1-1-nbsp-nbsp-三层逻辑"><a href="#1-1-1-nbsp-nbsp-三层逻辑" class="headerlink" title="1.1.1 &nbsp;&nbsp;三层逻辑"></a>1.1.1 &nbsp;&nbsp;三层逻辑</h4><p>先说明一下，这种分类仁者见仁，智者见智，能说清楚脉络就是好方法。</p>
<ul>
<li><strong>ServeMux</strong> 类型：有两大类方法：<br>(1) HandleFunc()、Handle() 创建其属性，m: map[string]muxEntry 路由和函数执行体；<br>(2) ServeHTTP()、Handler()、handler() 接收到请求后对 m 的路由查找，找到函数执行体；</li>
<li><strong>Server</strong> 类型：包含了 ServeMux 这个 Handler 接口类型，ListenAndServe() 和 Serve() 方法主要负责监听和接口请求，并启用 goroutine 调用下面 conn 类型的 serve()；</li>
<li><strong>conn</strong> 类型：包含了 Server 类型，serve() 方法，先通过 serverHandler 类型的 ServeHTTP() 方法 查找到 ServeMux，调用 ServeMux 的（2）相关方法找到函数执行体（也是一个 ServeHTTP() 方法）并执行。<br>这一下就提到三个 ServeHTTP() 方法，功能都是不一样的，第一个是用于查找 ServeMux，第二个是用于查找函数执行体，第三个是要执行的函数执行体，注意不要混淆了。</li>
</ul>
<p>一言以蔽之，先保存路由和函数执行体映射（ServeMux 准备阶段）；开启监听和等待连接，接受连接请求并新开一个 goroutine（Server 等待连接阻塞，承上启下）；通过查找映射找到函数执行体（conn 执行阶段）。<br>其中的监听、等待连接、接受连接是 Go 语言的实现，底层调用了 C 的接口。</p>
<h3 id="1-1-2-nbsp-nbsp-细节剖析"><a href="#1-1-2-nbsp-nbsp-细节剖析" class="headerlink" title="1.1.2 &nbsp;&nbsp;细节剖析"></a>1.1.2 &nbsp;&nbsp;细节剖析</h3><p>上面的三个类型中其实就是一层一层包含，里面通过一些重点内核函数（如监听连接等）或者辅助函数（如 serverHandler 等）实现该层的功能或逻辑。<br>在调用 <code>func ListenAndServe(addr string, handler Handler)</code> 函数的的时候，第二个就是可以自定义 Handler，也可以传 nil 表示使用 http.DefaultServeMux 进行处理，而下面是就设置 http.DefaultServeMux 中的 m 属性的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//句柄pattern1  通过一个结构体</span><br><span class="line">type Mux struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (Mux) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	fmt.Fprintln(w, &quot;welcome to china&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//句柄pattern2 通过一个函数</span><br><span class="line">type HandlerFunc func(http.ResponseWriter, *http.Request)</span><br><span class="line"></span><br><span class="line">func (f HandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	f(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//句柄pattern3 这其实和pattern2一样，只是调用的不是自定义的HandlerFunc，而是http.HandlerFunc</span><br><span class="line">func IndexHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	fmt.Fprintln(w, &quot;hello world&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func httpServe()&#123;</span><br><span class="line">	http.Handle(&quot;/pattern1&quot;, new(Mux))</span><br><span class="line">	http.Handle(&quot;/pattern2&quot;, HandlerFunc(IndexHandler))</span><br><span class="line">	http.Handle(&quot;pattern3&quot;, http.HandlerFunc(IndexHandler))</span><br><span class="line">	http.HandleFunc(&quot;/pattern4&quot;, IndexHandler)</span><br><span class="line">	http.ListenAndServe(&quot;:8000&quot;, nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-nbsp-nbsp-客户端"><a href="#1-2-nbsp-nbsp-客户端" class="headerlink" title="1.2 &nbsp;&nbsp;客户端"></a>1.2 &nbsp;&nbsp;客户端</h3><p>客户端的实现方式有很多种，下面我只实现两种。另外，理解 go 的 HTTP 最佳的方式是理解原代码，理解原代码的方式是进行服务端调试，要进行服务端的调度需要从客户端请求开始。</p>
<h4 id="1-2-1-nbsp-nbsp-基于-TCP-的-HTTP-客户端"><a href="#1-2-1-nbsp-nbsp-基于-TCP-的-HTTP-客户端" class="headerlink" title="1.2.1 &nbsp;&nbsp;基于 TCP 的 HTTP 客户端"></a>1.2.1 &nbsp;&nbsp;基于 TCP 的 HTTP 客户端</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpAddr, err := net.ResolveTCPAddr(&quot;tcp4&quot;, &quot;localhost:8000&quot;)</span><br><span class="line">conn, err := net.DialTCP(&quot;tcp&quot;, nil, tcpAddr)</span><br><span class="line">_, err = conn.Write([]byte(&quot;GET /pattern2 HTTP/1.1\r\nHost: localhost:8000\r\n\r\n&quot;))</span><br><span class="line">result, err := ioutil.ReadAll(conn)</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-nbsp-nbsp-基于-http-Client-的-HTTP-客户端"><a href="#1-2-2-nbsp-nbsp-基于-http-Client-的-HTTP-客户端" class="headerlink" title="1.2.2 &nbsp;&nbsp;基于 http.Client 的 HTTP 客户端"></a>1.2.2 &nbsp;&nbsp;基于 http.Client 的 HTTP 客户端</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">req, _ := http.NewRequest(&quot;GET&quot;, &quot;http://localhost:8000/pattern2&quot;, nil)</span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">resp, err := client.Do(req)</span><br></pre></td></tr></table></figure>
<h2 id="2-nbsp-nbsp-RPC"><a href="#2-nbsp-nbsp-RPC" class="headerlink" title="2 &nbsp;&nbsp;RPC"></a>2 &nbsp;&nbsp;RPC</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>RPC 是远程过程调用，或者说是远程方法调用、远程函数调用，多了一个“远程”，区别于同一进程空间内的方法或者函数调用，服务调用方须以网络的形式进行远程调用，是服务化框架的核心之一。<br>TCP/IP 和 HTTP 我把他们定位为实现数据传输，是协议设计。<br>RPC 和 Restful 我把他们定位为在数据传输基础上提供服务，是框架设计。<br>Restful 是基于 HTTP 的，但 RPC 可以基于 HTTP，也可以基于 TCP/IP。换句话说，HTTP 是面向“事先没有沟通”的普通用户，Restful 一般是面向“事先有简单沟通”的程序员（有后端的，但更多是前端），相对来说还是存在通用性设计；而 RPC 是面向“事先有良好沟通”的程序员（后端），所以可以去掉一些通用设计而采用精准功能设计，从而提高效率。<br>打个比喻，Restful 或者 HTTP 犹如有界面操作系统，事先用户简单学习甚至完全不需要学习其使用方式，用户自己摸索就能使用它；RPC 犹如命令操作系统，直接提供命令给你操作，前提是你得来学习命令或者函数操作方式，去掉“中间商赚差价”，所以效率提高了。</p>
<p>Go 语言标准包中已经提供了对 RPC 的支持，而且支持三个级别的 RPC：TCP(使用的标准包 net/rpc)、HTTP(使用的标准包 net/http、net/rpc)、JSONRPC(使用的标准包 net/rpc、net/rpc/jsonrpc)。但 Go 语言的 RPC 包是独一无二的 RPC，只支持 <strong>Go 语言开发的服务器与客户端之间的交互</strong>，因为在内部，它们采用了 Gob 来编码。所以如果是跨语言的，可以采用开源的 RPC，比如 gRPC，基于 HTTP，它采用 protocol 编码，支持很多语言，如 Java、Go、C++ 和 PHP 等。<br>下面我只讲解实现基于 TCP 的 Go 标准包 RPC（说明这个 RPC 是用 TCP 传输，且用了 Gob 编码），服务端和客户端都使用标准包 net/rpc。</p>
<h3 id="2-2-nbsp-nbsp-基于-TCP-的标准包-RPC"><a href="#2-2-nbsp-nbsp-基于-TCP-的标准包-RPC" class="headerlink" title="2.2 &nbsp;&nbsp;基于 TCP 的标准包 RPC"></a>2.2 &nbsp;&nbsp;基于 TCP 的标准包 RPC</h3>
      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/Golang/">Golang</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/Golang/">Golang</a>, <a href="/tags/网络/">网络</a>, <a href="/tags/Socket/">Socket</a>, <a href="/tags/RPC/">RPC</a>, <a href="/tags/HTTP/">HTTP</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:blog.jemper.cn">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C/">C</a><small>1</small></li>
  
    <li><a href="/categories/DevOps/">DevOps</a><small>2</small></li>
  
    <li><a href="/categories/Docker/">Docker</a><small>2</small></li>
  
    <li><a href="/categories/Golang/">Golang</a><small>6</small></li>
  
    <li><a href="/categories/HTTPS/">HTTPS</a><small>5</small></li>
  
    <li><a href="/categories/日记/">日记</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Compose/" style="font-size: 10px;">Compose</a> <a href="/tags/DevOps/" style="font-size: 10px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 13.33px;">Docker</a> <a href="/tags/Dockerfile/" style="font-size: 10px;">Dockerfile</a> <a href="/tags/Golang/" style="font-size: 20px;">Golang</a> <a href="/tags/Go包/" style="font-size: 13.33px;">Go包</a> <a href="/tags/HTTP/" style="font-size: 16.67px;">HTTP</a> <a href="/tags/HTTP2/" style="font-size: 13.33px;">HTTP2</a> <a href="/tags/HTTPS/" style="font-size: 13.33px;">HTTPS</a> <a href="/tags/RPC/" style="font-size: 10px;">RPC</a> <a href="/tags/SSL/" style="font-size: 10px;">SSL</a> <a href="/tags/Socket/" style="font-size: 13.33px;">Socket</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/TLS/" style="font-size: 16.67px;">TLS</a> <a href="/tags/io/" style="font-size: 13.33px;">io</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/协议/" style="font-size: 16.67px;">协议</a> <a href="/tags/容器化/" style="font-size: 10px;">容器化</a> <a href="/tags/密码学/" style="font-size: 10px;">密码学</a> <a href="/tags/工具/" style="font-size: 16.67px;">工具</a> <a href="/tags/并发/" style="font-size: 13.33px;">并发</a> <a href="/tags/微服务/" style="font-size: 10px;">微服务</a> <a href="/tags/性能/" style="font-size: 10px;">性能</a> <a href="/tags/架构/" style="font-size: 13.33px;">架构</a> <a href="/tags/生活/" style="font-size: 10px;">生活</a> <a href="/tags/编程/" style="font-size: 10px;">编程</a> <a href="/tags/网络/" style="font-size: 13.33px;">网络</a> <a href="/tags/调试/" style="font-size: 10px;">调试</a> <a href="/tags/部署/" style="font-size: 10px;">部署</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2019 Sven
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'wpxun';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
