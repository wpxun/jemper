<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Dockerfile 应用容器化及 Compose 部署应用 | 在路上</title>
  <meta name="author" content="Sven">
  
  <meta name="description" content="让大家读得懂的知识才是真知识">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Dockerfile 应用容器化及 Compose 部署应用"/>
  <meta property="og:site_name" content="在路上"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="在路上" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">在路上</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">关于我</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-04-15T09:00:14.000Z"><a href="/2019/04/15/docker-single-engine-mode/">2019-04-15</a></time>
      
      
  
    <h1 class="title">Dockerfile 应用容器化及 Compose 部署应用</h1>
  

    </header>
    <div class="entry">
      
        
			<div id="toc" class="toc-article">
				<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-nbsp-nbsp-shell-基础"><span class="toc-text">1   shell 基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-nbsp-nbsp-Dockerfile"><span class="toc-text">2   Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-nbsp-nbsp-命令"><span class="toc-text">2.1   命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-nbsp-nbsp-指令"><span class="toc-text">2.2   指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-nbsp-nbsp-Dockerfile-最佳实践"><span class="toc-text">2.3   Dockerfile 最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-nbsp-nbsp-Compose"><span class="toc-text">3   Compose</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-nbsp-nbsp-安装"><span class="toc-text">3.1   安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-nbsp-nbsp-命令"><span class="toc-text">3.2   命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-nbsp-nbsp-指令"><span class="toc-text">3.3   指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-nbsp-nbsp-实战部署"><span class="toc-text">4   实战部署</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-nbsp-nbsp-业务代码"><span class="toc-text">4.1   业务代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-nbsp-nbsp-容器化"><span class="toc-text">4.2   容器化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-nbsp-nbsp-单引擎部署"><span class="toc-text">4.3   单引擎部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-nbsp-nbsp-浏览器看结果"><span class="toc-text">4.4   浏览器看结果</span></a></li></ol></li></ol>
			</div>
		
        <p>将应用整合到容器中并且运行起来的这个过程，或者把应用打包成为一个镜像的过程，称为<strong>容器化</strong>，有时也叫作“Docker 化”。容器化核心就是创建镜像，创建镜像有两种方式，一种是 commit 容器，还有一种是使用 Dockerfile 快速创建自定义镜像。</p>
<p>docker compose 能够在 Docker 节点上，以<strong>单引擎模式(Single-Engine Mode)</strong>进行多容器应用的部署和管理。它区别于 Swarm 和 Kubernetes 可以进行多引擎多容器应用部署(在 docker 中叫 swarm mode，Compose does not use swarm mode to deploy services to multiple nodes in a swarm)。compose 和 Kubernetes 其适用范围不同，所以不适合作对比。<br><a id="more"></a></p>
<h2 id="1-nbsp-nbsp-shell-基础"><a href="#1-nbsp-nbsp-shell-基础" class="headerlink" title="1 &nbsp;&nbsp;shell 基础"></a>1 &nbsp;&nbsp;shell 基础</h2><ol>
<li><p>熟悉 shell 语法，比如<code>$</code>的应用规则：$?(上一个命令的返回值)、$0 $1 $2（表示指令，参数1、参数2）、$() = ` `、$NAME（引用变量）等，脚本经常会先执行 set -xe（e 表示单个命令执行返回非零时立即退出，包括函数返回非零，x 执行指令前会先显示该完整的命令）。</p>
</li>
<li><p>理解程序运行的原理，shell 是一个等待输入的程序，输入的命令有外部命令和内部命令之分；外部命令是通过系统调用或独立的程序实现的，如 sed、awk 等。内部命令是由特殊的文件格式（.def）所实现，如 cd、history、exec、source 等。其接收到指令后有三种方式运行：<br>（1）在当前的 shell 上运行<br>（2）fork 新的 shell 运行，环境变量会从父进程传递给子进程<br>（3）系统调用 exec 函数簇执行，一般是 fork 父进程，父子进程拥有共同的地址空间，只有当子进程需要写入数据时(如向缓冲区写入数据),这时候会复制地址空间，复制缓冲区到子进程中去。<br>同理，运行一个脚本也有三种方式一一对应上面三种，当然前提是有一个已经在运行的 shell。<br>（1）source：也就是 <code>. 命令</code>，在当前上下文中执行脚本，不会生成新的进程。脚本执行完毕，shell 继续等待输入。影响上下文；<br>（2）<code>./script.sh</code>（以 #!/bin/sh 开头） 与 <code>sh script.sh</code>（无需 #!/bin/sh 开头） 等效，当前shell是父进程，fork 子 shell 进程，在子 shell 进程中执行脚本。脚本执行完毕，退出子shell，回到当前shell。不影响上下文。<br>（3）执行完不返回 shell，直接退出 shell，关闭上下文。<br>如以下脚本，通过 <code>. jump.sh</code> 后返回到原来的 shell 其当前目录也变了成 /，而 <code>./jump.sh 或 sh jump.sh</code> 则不会影响上下文。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; jump.sh</span><br><span class="line">#!/bin/sh</span><br><span class="line">cd /</span><br><span class="line">pwd</span><br><span class="line">echo $HOME</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-nbsp-nbsp-Dockerfile"><a href="#2-nbsp-nbsp-Dockerfile" class="headerlink" title="2 &nbsp;&nbsp;Dockerfile"></a>2 &nbsp;&nbsp;Dockerfile</h2><p>Dockerfile 具有众多的指令。一般分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。</p>
<h3 id="2-1-nbsp-nbsp-命令"><a href="#2-1-nbsp-nbsp-命令" class="headerlink" title="2.1 &nbsp;&nbsp;命令"></a>2.1 &nbsp;&nbsp;命令</h3><p>镜像常用 Dockerfile 指令文件创建，创建命令：<code>docker image build -t NAME[:TAG] Dockerfile-Path</code>。它几乎无需指定参数，但还是简单说明几个：</p>
<ul>
<li>–rm 成功 build 后删除中间运行的容器，默认为true。还有一个 –force-rm，无论成不成功都删除，不建议使用，因为失败了还可以通过容器调试。<br>注意这里要区别于中间镜像，在 build 中 <code>---&gt; cdf98d1859c1</code> 表示依赖的镜像或者中间镜像，<code>---&gt; Running in 1d2485ce71e9</code> 表示中间容器。</li>
<li>–no-cache 不走缓存。构建的时候会搜索开始到当前的指令是否有缓存，有则直接拿来用提升速度，但有注意 COPY、ADD 指定即使没变也会检查复制的文件有没有改动过。既然缓存会自动判断，那为什么要设置不走缓存，那是因为像 RUN，即使命令都没变，但可能因为时间、远程版本变化导致运行结果也有变化，这时候就可以指定不走缓存。</li>
<li>–squash，压缩层，即把所有的层压缩成一个层，这对本地使用还好，对需要 pull、push 的增加了网络负担。所以尽量不用，而是在 Dockerfile 里选择性的合并指令达到压缩层的目的。像 git 也有该参数，同样各有利弊。</li>
</ul>
<h3 id="2-2-nbsp-nbsp-指令"><a href="#2-2-nbsp-nbsp-指令" class="headerlink" title="2.2 &nbsp;&nbsp;指令"></a>2.2 &nbsp;&nbsp;指令</h3><p>有些指令会新建镜像层，有些只会增加元数据，关于如何区分命令是否会新建镜像层，一个基本的原则是，<strong>如果指令的作用是向镜像中增添新的文件或者程序，那么这条指令就会新建镜像层；</strong>如果只是告诉 Docker 如何完成构建或者如何运行应用程序，那么就只会增加镜像的元数据。所以并非所有的 RUN 都会有创建新层，比如 <code>RUN echo &quot;no data&quot;</code> 就不会创建新的层。</p>
<p>需要注意的一点是镜像<strong>没有任何运行时的宿主机信息</strong>，比如不可能有端口映射，端口映射一定是在启动容器的时候才会指定，否则宿主机的端口未知是否可用，则容器也未知是否可用。</p>
<p>下面列举一些常用的指令：</p>
<ul>
<li>FROM：指定基础镜像，推荐 Alpine，只有 5M 左右；</li>
<li><p>RUN：有 shell 和 exec 两种执行方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN &lt;command&gt;  //shell</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]  //exec</span><br></pre></td></tr></table></figure>
</li>
<li><p>COPY、ADD：COPY 只能复制宿主机文件，ADD 支持远端复制，并且会自动解压压缩文件，不过不会删除压缩文件。</p>
</li>
<li><p>EXPOSE、-p、-P：设置镜像暴露端口，容器启动时就会监听的端口，<strong>但是不导出（publish）端口到主机，不过容器之间 link 可以使用暴露的端口通信</strong>。docker run 命令的 -p 和 -P 表示是否设置容器的端口到宿主机的映射； 其中 -P 表示将 EXPOSE 暴露的端口映射到本地主机的随机端口；-p 设置容器新暴露端口并映射到宿主机的指定端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPOSE 80   //Dockerfile</span><br><span class="line">------------------------</span><br><span class="line">PORTS</span><br><span class="line">80/tcp, 0.0.0.0:91-&gt;8080/tcp  //80端口只是暴露没有导出，只能用于容器之间的 link；-p 91:8080</span><br><span class="line">0.0.0.0:32768-&gt;80/tcp, 0.0.0.0:90-&gt;8080/tcp // 80端口导出到宿主机随机端口；-P -p 90:8080</span><br></pre></td></tr></table></figure>
</li>
<li><p>ENTRYPOINT、CMD、docker run 的命令：</p>
<ul>
<li>Dockerfile 中应至少一条 CMD 或 ENTRYPOINT 指令，如果有多条，他们都是最后一条生效；而且逻辑是 CMD 在后面，如果不写在后面也不会报错，不过还是会追回在 ENTRYPOINT 参数后面；</li>
<li>CMD 和 docker run 本质上是一样的，只不过前者是默认，后者会覆盖前者；如果有 ENTRYPOINT 指令，则他们只能是 ENTRYPOINT 指令的追加参数；</li>
<li>docker run 中加入 –entrypoint，会覆盖镜像中的 ENTRYPOINT；</li>
<li>当使用容器作为一个程序容器时，应使用 ENTRYPOINT 定义入口程序。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]  //exec， json数组格式，所有参数都必须有双引号</span><br><span class="line">CMD [&quot;param1&quot;, &quot;param2&quot;]  // 结合 ENTRYPOINT 指令追加参数</span><br><span class="line">CMD command param1 param2  //shell</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]  //exec， json数组格式，所有参数都必须有双引号</span><br><span class="line">ENTRYPOINT command param1 param2  //shell</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>WORKDIR：需要注意如果是相对路径，则会以上一条绝对路径为前缀，像 cd 改变目录的功能。</p>
</li>
<li><p>USER：如果容器中的应用程序运行时不需要特殊权限，则可以通过 USER 指令把应用程序的所有者设置为非 root 用户。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</span><br><span class="line">USER postgres</span><br></pre></td></tr></table></figure>
</li>
<li><p>ENV：有两种方式，但推荐第二种减少中间镜像数量</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;</code>，这种情况字符串有空格一定要用双引号括起来</li>
</ul>
</li>
<li><p>VOLUME、-v：挂载卷，启动容器的时候会把容器中的目录挂载到宿主机中。docker run 的 -v 是可以指定宿主机的目录名的。</p>
</li>
</ul>
<h3 id="2-3-nbsp-nbsp-Dockerfile-最佳实践"><a href="#2-3-nbsp-nbsp-Dockerfile-最佳实践" class="headerlink" title="2.3 &nbsp;&nbsp;Dockerfile 最佳实践"></a>2.3 &nbsp;&nbsp;Dockerfile 最佳实践</h3><ol>
<li>让层尽量的少，加快编译时间；但是保留共用层，避免 push 或 pull 重复的数据<ul>
<li>RUN 时一般使用 <code>\</code> 把长的指令分成多行，把多个 RUN 指令合并成一个 RUN 指令，达到压缩镜像层的目的；</li>
<li>ENV <code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;</code> 减少中间镜像层</li>
</ul>
</li>
<li>让镜像的大小尽量的小，只留必要的文件，其它的如构建工具、依赖、代码等如对服务没有帮助则应该删除<ul>
<li>运行结束后应该清理缓存和中间工具使得每一层的 SIZE 最小，这主要有两种方式：<ul>
<li>编写命令清理不需要的数据，php 镜像就是这么干的，apk add –no-cache –virtual .build-deps 和 apk del .build-deps；phpize 和 docker-php-source delete等；</li>
<li>建造者模式：把有用的数据移到最小版本，需要多个 Dockerfile；</li>
<li>多阶段构建方式：利用 COPY –from 参数指定要复制指定的数据，只需要一个 Dockerfile。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="3-nbsp-nbsp-Compose"><a href="#3-nbsp-nbsp-Compose" class="headerlink" title="3 &nbsp;&nbsp;Compose"></a>3 &nbsp;&nbsp;Compose</h2><h3 id="3-1-nbsp-nbsp-安装"><a href="#3-1-nbsp-nbsp-安装" class="headerlink" title="3.1 &nbsp;&nbsp;安装"></a>3.1 &nbsp;&nbsp;安装</h3><p>三大版本的关系：docker compose 版本、Compose file format 版本和 Docker Engine 版本，可以参见 github 库 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">docker/compose</a>。比如 docker compose v1.21.0 只能支持 Compose file format v3.6 基于 Docker Engine v18.02.0+，docker compose v1.22.0 才增加了 Compose file format v3.7，而且 docker-compose.yml specification v3.7 版本要求 Docker Engine 在 v18.06.0 以上；目前最新的 docker compose v1.24.0 只能支持 Compose file format v3.7 基于 Docker Engine v18.06.0+。<br>版本号如果写成 version: ‘3’，则表示为 3.0 版本。关于 docker compose file format 的差异可以看 <a href="https://docs.docker.com/compose/compose-file/compose-versioning/" target="_blank" rel="noopener">Compose file versions and upgrading</a>。</p>
<p>docker compose 是收购 fig，它是一个 python 工具，按<a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">官方下载</a>就可以了；升级也很简单，重新下载一次就可以了。</p>
<h3 id="3-2-nbsp-nbsp-命令"><a href="#3-2-nbsp-nbsp-命令" class="headerlink" title="3.2 &nbsp;&nbsp;命令"></a>3.2 &nbsp;&nbsp;命令</h3><ul>
<li>up：启动，-d 表示后台运行；</li>
<li>down：关闭，会把容器和网络删除，但不会删除卷；</li>
<li>logs：如果加了 -d 参数，可以通过该命令查看日志，但日志的输出是依赖于服务内部的设计的；</li>
<li>build：重建镜像用 <code>docker-compose build</code> or <code>docker-compose up --build</code>；</li>
</ul>
<h3 id="3-3-nbsp-nbsp-指令"><a href="#3-3-nbsp-nbsp-指令" class="headerlink" title="3.3 &nbsp;&nbsp;指令"></a>3.3 &nbsp;&nbsp;指令</h3><p>需要注意的是可以在 Compose 文件中用<code>$</code>直接引用宿主机的变量，而 Dockerfile 文件是不行的，<code>$</code>只是引用 ENV 定义的变量。下面以 3.7 版本格式列举一些常见的指令：</p>
<p>一级指令：</p>
<ul>
<li>version：版本号，规定版本的格式</li>
<li>services：服务<ul>
<li>build：本地找，找不到就构建，如果指定 image 则用其值，如没有就用 “服务名:latest“</li>
<li>image：如指定 build 则其规则看 build；如未指定 build，则本地找，本地没有上 hub 拉取</li>
<li>environment：在 docker-compose 运行时导入容器，这极大的方便了引用宿主机环境变量</li>
</ul>
</li>
<li>networks：网络</li>
<li>volumes：卷</li>
</ul>
<h2 id="4-nbsp-nbsp-实战部署"><a href="#4-nbsp-nbsp-实战部署" class="headerlink" title="4 &nbsp;&nbsp;实战部署"></a>4 &nbsp;&nbsp;实战部署</h2><p>本节以一个计数器进行实战部署，目录结构：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; tree gomicro</span><br><span class="line">gomicro</span><br><span class="line">├── config.yaml</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── main.go</span><br><span class="line">└── service</span><br><span class="line">    ├── config.go</span><br><span class="line">    └── redis.go</span><br></pre></td></tr></table></figure></p>
<p>除了 Dockerfile 和 docker-compose.yml，其余的都是业务代码。</p>
<h3 id="4-1-nbsp-nbsp-业务代码"><a href="#4-1-nbsp-nbsp-业务代码" class="headerlink" title="4.1 &nbsp;&nbsp;业务代码"></a>4.1 &nbsp;&nbsp;业务代码</h3><ol>
<li>使用 go 作为 web 服务器，开发路径为 <code>$GOPATH/github.com/wpxun/gomicro</code>，开发环境和生产环境保持一致，需要发布 80 端口；</li>
<li>使用 redis 存储计数，并作持久存储，该服务只供 go web 服务请求，所以暴露的端口(6379)不需要发布；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; $GOPATH/github.com/wpxun/gomicro/main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;github.com/wpxun/gomicro/service&quot;</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func IndexHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    redis := service.GetRedis()</span><br><span class="line">    val, err := redis.Incr(&quot;count&quot;).Result()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    host := os.Getenv(&quot;FROMHOSTNAME&quot;) //读取 docker-compose.yml 中引入到容器的环境变量</span><br><span class="line">    fmt.Fprintln(w, &quot;hello world &quot;+ host +&quot;, visitors = &quot; + strconv.FormatInt(val, 10) )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">    http.Handle(&quot;/pattern&quot;, http.HandlerFunc(IndexHandler))</span><br><span class="line">    http.ListenAndServe(&quot;:80&quot;, nil)</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; $GOPATH/github.com/wpxun/gomicro/config.yaml</span><br><span class="line">Redis:</span><br><span class="line">  DialTimeout: 2000000000 #连接超时设定(s)，默认200ms</span><br><span class="line">  Network: tcp #网络连接协议</span><br><span class="line">  Address: redis:6379 #连接地址(带端口)</span><br><span class="line">  Password:  #密码</span><br><span class="line">  Database: 0 #数据库，默认0</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; $GOPATH/github.com/wpxun/gomicro/service/redis.go</span><br><span class="line">package service</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/go-redis/redis&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetRedis() *redis.Client &#123;</span><br><span class="line">    return redis.NewClient(&amp;redis.Options &#123;</span><br><span class="line">        Addr:         Conf.Redis.Address,</span><br><span class="line">        Password:     Conf.Redis.Password,</span><br><span class="line">        DB:           Conf.Redis.Database,</span><br><span class="line">        Network:      Conf.Redis.Network,</span><br><span class="line">        DialTimeout:  Conf.Redis.DialTimeout,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; $GOPATH/github.com/wpxun/gomicro/service/config.go</span><br><span class="line">package service</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;gopkg.in/yaml.v2&quot;</span><br><span class="line">    &quot;io/ioutil&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type confstruct struct &#123;</span><br><span class="line">    Redis struct &#123;</span><br><span class="line">        Address     string          `yaml:&quot;Address&quot;`</span><br><span class="line">        Database    int             `yaml:&quot;Database&quot;`</span><br><span class="line">        DialTimeout time.Duration   `yaml:&quot;DialTimeout&quot;`</span><br><span class="line">        Network     string          `yaml:&quot;Network&quot;`</span><br><span class="line">        Password    string          `yaml:&quot;Password&quot;`</span><br><span class="line">    &#125; `yaml:&quot;Redis&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Conf confstruct</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">    GetYaml(&quot;config&quot;, &amp;Conf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GetYaml(filename string, out interface&#123;&#125;) &#123;</span><br><span class="line">    yamlFile, err := ioutil.ReadFile(fmt.Sprintf(&quot;%s.yaml&quot;, filename))</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;Read config file error:&quot;, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = yaml.Unmarshal(yamlFile, out)</span><br><span class="line"></span><br><span class="line">    if (err != nil) &#123;</span><br><span class="line">        fmt.Println(&quot;Unmarshal config file error:&quot;, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h3 id="4-2-nbsp-nbsp-容器化"><a href="#4-2-nbsp-nbsp-容器化" class="headerlink" title="4.2 &nbsp;&nbsp;容器化"></a>4.2 &nbsp;&nbsp;容器化</h3><p>这一步我们只需要把 go web 服务器容器化，而 redis 我们直接用官方的容器。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; $GOPATH/github.com/wpxun/gomicro/Dockerfile</span><br><span class="line"># 多阶段构建</span><br><span class="line"># 第一阶段，391MB，编译前准备：go 和 git 工具、代码依赖库</span><br><span class="line">FROM golang:1.12.4-alpine3.9  AS front</span><br><span class="line">RUN set -xe &amp;&amp; \</span><br><span class="line">    apk add git &amp;&amp; \</span><br><span class="line">    go get -v github.com/go-redis/redis &amp;&amp; \</span><br><span class="line">    go get -v gopkg.in/yaml.v2</span><br><span class="line"></span><br><span class="line"># 分成两次 RUN 目的是可复用上面的缓存，编译 go 代码</span><br><span class="line">COPY . /go/src/github.com/wpxun/gomicro</span><br><span class="line">RUN set -xe &amp;&amp; \</span><br><span class="line">    go install github.com/wpxun/gomicro</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第二阶段，14.6MB；仅仅复制了可执行程序和程序的配置文件</span><br><span class="line">FROM alpine:3.9</span><br><span class="line">ENV GOM_VERSION   1904.1</span><br><span class="line">COPY --from=front /go/bin /go/src/github.com/wpxun/gomicro/config.yaml /go/bin/</span><br><span class="line">EXPOSE 80</span><br><span class="line">WORKDIR /go/bin</span><br><span class="line">CMD [&quot;/go/bin/gomicro&quot;]</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p>
<p>我们采用多阶段构建，最终只需要 go web 服务器的可执行程序和启动时需要读取的配置文件，这里我把他们放在 /go/bin 目录下，因为 go 程序中基于当前目录读取的 config.yaml，所以需要设置工作目录为配置文件所在的目录 WORKDIR /go/bin。</p>
<h3 id="4-3-nbsp-nbsp-单引擎部署"><a href="#4-3-nbsp-nbsp-单引擎部署" class="headerlink" title="4.3 &nbsp;&nbsp;单引擎部署"></a>4.3 &nbsp;&nbsp;单引擎部署</h3><p>这一步我们需要把 go web 服务和 redis 服务进行编排管理，两者的通信需要配置同一个 networks。而且还在运行容器的时候添加 FROMHOSTNAME 环境变量等于宿主机的 HOSTNAME 环境变量，这里要注意，运行时的 compose 里的环境变量是宿主机的环境变量，而构建时的 Dockerfile 不能包含宿主机的信息（build 的时候可以通过 –build-arg 传变量）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; $GOPATH/github.com/wpxun/gomicro/docker-compose.yml</span><br><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  gomicro:</span><br><span class="line">    build: .</span><br><span class="line">    image: wpxun/gomicro:v1</span><br><span class="line">    environment:</span><br><span class="line">      FROMHOSTNAME: $HOSTNAME</span><br><span class="line">    ports:</span><br><span class="line">      - target: 80</span><br><span class="line">        published: 80</span><br><span class="line">    networks:</span><br><span class="line">      - counter-net</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: &quot;redis:5.0.4-alpine3.9&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - counter-net</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  counter-net:</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  counter-vol:</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p>
<h3 id="4-4-nbsp-nbsp-浏览器看结果"><a href="#4-4-nbsp-nbsp-浏览器看结果" class="headerlink" title="4.4 &nbsp;&nbsp;浏览器看结果"></a>4.4 &nbsp;&nbsp;浏览器看结果</h3><p><code>docker-compose up -d</code> 运行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; docker ps -a</span><br><span class="line">IMAGE                   COMMAND                  CREATED             STATUS                     PORTS                                      NAMES</span><br><span class="line">gomicro_gomicro         &quot;/go/bin/gomicro&quot;        3 hours ago         Up 2 hours                 0.0.0.0:80-&gt;80/tcp                         gomicro_gomicro_1</span><br><span class="line">edis:5.0.4-alpine3.9    &quot;docker-entrypoint.s…&quot;   3 hours ago         Up 2 hours                 6379/tcp                                   gomicro_redis_1</span><br></pre></td></tr></table></figure></p>
<p>访问 <code>http://&lt;ip&gt;/pattern</code> 即可以看到打印的次数加 1。如果容器被 stop，计数次数保留，如果容器被 down 掉（也就是容器被删除），则计数丢失。当然可以把 redis 的数据保存在卷中，这样即使容器被删除，redis 持久化数据还在卷中，下次重启可以挂载。</p>
<p><br><br><br></p>
<p> <strong>参考文献</strong><br>[1] Nigel Poulton. 深入浅出 Dokcer. 版次：2019年4月第1版<br>[2] 廖煜 晏东. Docker 容器实战. 版次：2016年11月第1版<br>[3] Dockerfile 最佳实践. <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/</a></p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/Docker/">Docker</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/Docker/">Docker</a>, <a href="/tags/容器/">容器</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:blog.jemper.cn">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C/">C</a><small>1</small></li>
  
    <li><a href="/categories/DevOps/">DevOps</a><small>3</small></li>
  
    <li><a href="/categories/Docker/">Docker</a><small>4</small></li>
  
    <li><a href="/categories/Golang/">Golang</a><small>6</small></li>
  
    <li><a href="/categories/HTTP/">HTTP</a><small>5</small></li>
  
    <li><a href="/categories/云原生/">云原生</a><small>8</small></li>
  
    <li><a href="/categories/日记/">日记</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Docker/" style="font-size: 18px;">Docker</a> <a href="/tags/Golang/" style="font-size: 16px;">Golang</a> <a href="/tags/Go包/" style="font-size: 12px;">Go包</a> <a href="/tags/HTTP/" style="font-size: 14px;">HTTP</a> <a href="/tags/Jenkins/" style="font-size: 10px;">Jenkins</a> <a href="/tags/Kubernetes/" style="font-size: 20px;">Kubernetes</a> <a href="/tags/RPC/" style="font-size: 10px;">RPC</a> <a href="/tags/Service-Mesh/" style="font-size: 14px;">Service Mesh</a> <a href="/tags/Socket/" style="font-size: 12px;">Socket</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/TLS/" style="font-size: 14px;">TLS</a> <a href="/tags/io/" style="font-size: 12px;">io</a> <a href="/tags/协议/" style="font-size: 14px;">协议</a> <a href="/tags/容器/" style="font-size: 14px;">容器</a> <a href="/tags/密码学/" style="font-size: 10px;">密码学</a> <a href="/tags/工具/" style="font-size: 14px;">工具</a> <a href="/tags/并发/" style="font-size: 12px;">并发</a> <a href="/tags/架构/" style="font-size: 10px;">架构</a> <a href="/tags/编程/" style="font-size: 10px;">编程</a> <a href="/tags/网络/" style="font-size: 12px;">网络</a> <a href="/tags/调试/" style="font-size: 10px;">调试</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2019 Sven
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'wpxun';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
